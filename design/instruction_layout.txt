registers:
    zero     0000 -> zero register
    gp       0001 -> global pointer
    sp       0010 -> stack pointer
    bp       0011 -> base pointer
    ra       0100 -> return address
    r0       0101 -> scratch register 1
    r1       0110 -> scratch register 2
    r2       0111 -> scratch register 3
    r3       1000 -> scratch register 4
    r4       1001 -> scratch register 5
    r5       1010 -> scratch register 6
    r6       1011 -> scratch register 7
    r7       1100 -> scratch register 8
    r8       1101 -> scratch register 9
    r9       1110 -> scratch register 10
    r10      1111 -> scratch register 11

opcodes:
    // THREE ARGUMENT INSTRUCTIONS
    add     00000 ->
    sub     00001 ->
    and     00010 ->
    or      00011 ->
    xor     00100 ->

    // BRANCH INSTRUCTIONS
    jxx     00101 ->

    // MEMORY INSTRUCTIONS
    st      00110 ->
    ld      00111 ->

    // IMMEDIATE INSTRUCTIONS
    lui     01000 ->
    lli     01001 ->
    li      01010 ->

    // ONE ARGUMENT INSTRUCTIONS
    int     01011 ->

jump conditions:
    z      0000 -> zero
    nz     0001 -> not zero
    gz     0010 -> greater than zero
    lz     0011 -> less than zero
    ge     0100 -> greater than or equal to zero
    le     0101 -> less than or equal to zero

instruction layouts (32 bits):
    // THREE ARGUMENT INSTRUCTIONS
        // ONE DESTINATION, TWO SOURCES, ONE SOURCE HAS OFFSET
    opcode      5 bits
    rd          4 bits
    offset_src  1 bit
    rs1         4 bits
    rs2         4 bits
    offset     14 bits

    // CONDITIONAL BRANCH INSTRUCTION
        // ONE CONDITION, TWO SOURCES, ONE SOURCE HAS OFFSET
    opcode      5 bits
    cond        4 bits
    offset_reg  1 bit
    rjaddr      4 bits
    rs          4 bits
    offset     13 bits
    rel_jmp     1 bit

    // MEMORY READ INSTRUCTION
        // ONE DESTINATION, ONE SOURCE, ONE HAS OFFSET
    opcode      5 bits
    rd          4 bits
    offset_src  1 bit
    raddr       4 bits
    offset     18 bits

    // MEMORY WRITE INSTRUCTION
        // ONE SOURCE, ONE DESTINATION, ONE HAS OFFSET
    opcode      5 bits
    offset      4 bits
    offset_src  1 bit
    raddr       4 bits
    rs          4 bits
    offset     14 bits

    // IMMEDIATE INSTRUCTIONS
        // ONE DESTINATION, ONE IMMEDIATE
    opcode      5 bits
    rd          4 bits
    imm        23 bits

|31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0|
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
|                  offset                 |    rs2    |    rs1    |os|    rd     |    opcode    |   // THREE ARGUMENT INSTRUCTIONS
|rj|                offset                |    rs     |  rjaddr   |or|   cond    |    opcode    |   // CONDITIONAL BRANCH INSTRUCTION
|                       offset                        |   raddr   |os|    rd     |    opcode    |   // MEMORY READ INSTRUCTION
|                  offset                 |    rs     |   raddr   |os|  offset   |    opcode    |   // MEMORY WRITE INSTRUCTION
|                                imm                                 |    rd     |    opcode    |   // IMMEDIATE INSTRUCTIONS


EXAMPLE PROGRAM:
00000000 00000000 00000000 10101010    // SET THE COUNTER TO 0

00000000 00000100 00010110 10100000     // INCREMENT THE COUNTER BY 1
00000000 00000000 00000000 00000101     // JUMP TO THE START